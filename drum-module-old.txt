const int sensorPin = A0;

const int sampleStartThreshold = 10;
const long sampleDuration = 4000; // microseconds
const long cutoffDuration = 15000; // microseconds 
float cutoffOverrideFactor = 1.2; // ie: 1.2 = must be 20% higher than peak to override cutoff period


/**
 * The cutoff period is used to filter out reflections of the drum head.
 * When a trigger happens, a cutoff timer is started, and any inputs in 
 * the cutoff period are ignored UNLESS they are of a greater amplitude.
 * This still allows us to catch things like flams
 */
bool inCutoffPeriod = false;
int cutoffPeak = 0; // Value of the trigger when cutoff period started
long cutoffStart = 0; // micros() when the cutoff period started

bool isNoteOn = false;
long noteOnTime = 0;

void setup() {
//  Serial.begin(31250);
  Serial.begin(9600);
}


/**
 * Reads an analog input for the given amount of time and returns
 * the highest value in that period.
 */
int getSample(int inputPin, long durationMicros, int threshold) {
  int value = analogRead(inputPin);
  int peak = value;

  if (value < threshold) {
    return 0;
  }

  // We're over the threshold. Start sampling
  long start = micros();
  while (micros() - start < durationMicros) {
    // Catch instances of micros() overflowing back to 0
    if (micros() < start) {
      break;
    }
    value = analogRead(inputPin);
    if (value > peak) {
      peak = value;
    }
  }
  return peak;
}


void sendMIDINoteOn(int pitch, int velocity) {
  Serial.write(0x90);
  Serial.write(pitch);
  Serial.write(velocity);
}

void sendMIDINoteOff(int pitch) {
  Serial.write(0x80);
  Serial.write(pitch);
  Serial.write(0);
}



void loop() {
  int sensorReading = getSample(sensorPin, sampleDuration, sampleStartThreshold);

  /**
   * If enough time has passed, exit the cutoff period
   */
  if (micros() - cutoffStart > cutoffDuration) {
    inCutoffPeriod = false;
  }


  /**
   * Catch cases of micros() overflowing to 0.
   * FIXME: Handle this better (what if cutoffStart was only a few microseconds from the max value?)
   */
  if (micros() < cutoffStart) {
    inCutoffPeriod = false;
  }


  /**
   * If the sensor reading is higher than the value at which the cutoff period was started,
   * this probably isn't a reflection, and might be something like a flam, so override the cutoff
   */
  bool overrideCutoff = false;
  if (inCutoffPeriod) {
    if (sensorReading > cutoffPeak * cutoffOverrideFactor) {
      overrideCutoff = true;
    }
  }


  /**
   * We want to trigger if the sensor reading is over the threshold (obviously) AND we're either not in a cutoff
   * period, or the sensor reading is higher than the value that trigger the cutoff (probably not a reflection)
   */
  if (sensorReading > threshold && (!inCutoffPeriod || overrideCutoff)) {
    if (isNoteOn) {
      sendMIDINoteOff(38);
      isNoteOn = false;
    }
    
    int velocity = ((float)sensorReading / 1024.0) * 127.0;
    sendMIDINoteOn(38, velocity);
    isNoteOn = true;
    noteOnTime = micros();
    
    cutoffPeak = sensorReading;
    cutoffStart = micros();
    inCutoffPeriod = true;
  }


  // Send note off command 100ms after note on
  if (isNoteOn && micros() - noteOnTime > 100000 || micros() < noteOnTime) {
    sendMIDINoteOff(38);
    isNoteOn = false;
  }
}
